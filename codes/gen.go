//go:build ignore

// This program generates iata.go by downloading airport data from OpenFlights
// and mapping each IATA code to its IANA timezone.
//
// Usage: go generate ./codes/...
package main

import (
	"bufio"
	"bytes"
	"encoding/csv"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"os"
	"sort"
	"strings"
)

const (
	// OpenFlights airports-extended.dat - includes IANA timezone and more locations
	// (train stations, smaller airports, etc.)
	// Format: ID, Name, City, Country, IATA, ICAO, Lat, Lon, Alt, TZ Offset, DST, Timezone, Type, Source
	airportsURL = "https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports-extended.dat"
	outputFile  = "iata.go"
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("gen: ")

	log.Println("Downloading airport data from OpenFlights...")
	airports, err := downloadAirports()
	if err != nil {
		log.Fatalf("Failed to download airports: %v", err)
	}
	log.Printf("Downloaded %d IATA codes with timezone mappings", len(airports))

	log.Println("Generating iata.go...")
	if err := generateCode(airports); err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}
	log.Println("Done!")
}

// downloadAirports fetches the OpenFlights CSV and returns a map of IATA code to timezone.
func downloadAirports() (map[string]string, error) {
	resp, err := http.Get(airportsURL)
	if err != nil {
		return nil, fmt.Errorf("HTTP GET failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status: %s", resp.Status)
	}

	return parseOpenFlightsCSV(resp.Body)
}

// parseOpenFlightsCSV parses the OpenFlights airports.dat format.
// Columns: ID(0), Name(1), City(2), Country(3), IATA(4), ICAO(5), Lat(6), Lon(7),
// Alt(8), TZ Offset(9), DST(10), Timezone(11), Type(12), Source(13)
func parseOpenFlightsCSV(r io.Reader) (map[string]string, error) {
	reader := csv.NewReader(bufio.NewReader(r))
	reader.FieldsPerRecord = -1 // Allow variable number of fields

	airports := make(map[string]string)

	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("failed to read CSV: %w", err)
		}

		// Need at least 12 columns (up to timezone)
		if len(record) < 12 {
			continue
		}

		iata := strings.TrimSpace(record[4])
		timezone := strings.TrimSpace(record[11])

		// Skip entries without IATA code or timezone
		if iata == "" || iata == "\\N" || iata == "-" {
			continue
		}
		if timezone == "" || timezone == "\\N" || timezone == "-" {
			continue
		}

		// Validate IATA code format: 3 alphanumeric characters, starting with a letter
		// (filters out Cyrillic codes, numeric-only codes, etc.)
		if !isValidIATA(iata) {
			continue
		}

		// Validate timezone looks like IANA format (contains /)
		if !strings.Contains(timezone, "/") {
			continue
		}

		// Store the mapping (later entries overwrite earlier ones if duplicates)
		airports[iata] = timezone
	}

	return airports, nil
}

// isValidIATA checks if a string is a valid IATA code.
// Valid codes are 3 alphanumeric ASCII characters, starting with a letter.
// NOTE: This duplicates codes.IsValidIATA because gen.go is a standalone program.
func isValidIATA(s string) bool {
	if len(s) != 3 {
		return false
	}
	// First character must be a letter
	if c := s[0]; !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
		return false
	}
	// Remaining characters must be alphanumeric
	for i := 1; i < len(s); i++ {
		c := s[i]
		if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
			return false
		}
	}
	return true
}

// generateCode writes the iata.go file with the given mappings.
func generateCode(airports map[string]string) error {
	var buf bytes.Buffer

	buf.WriteString(`// Code generated by go generate; DO NOT EDIT.
// Source: OpenFlights (https://github.com/jpatokal/openflights)

// Package codes provides IATA airport code to timezone mappings.
package codes

// IATA maps airport codes to their corresponding IANA timezone identifiers.
// For example, "SFO" maps to "America/Los_Angeles".
var IATA = map[string]string{
`)

	// Sort keys for deterministic output
	keys := make([]string, 0, len(airports))
	for k := range airports {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, code := range keys {
		tz := airports[code]
		buf.WriteString(fmt.Sprintf("\t%q: %q,\n", code, tz))
	}

	buf.WriteString("}\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format code: %w", err)
	}

	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}
